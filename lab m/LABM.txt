introduction: This deals with the memory component of the CPU this includes memory/ RAM, register file storing all the registers which store words through flip-flops. We also build some modules which preform some actions done by the CPU such as fetching instructions, decoding, executing the instructions, writing back into the destination register, updating the program counter for the next instruction.

labm1.v
This program initializes the register program from Verilog with inputs d, clk, enable and output z. d will be used to write into the register. But d will only be written after clk rises from 0 to 1 and enable is set to 1. This program will test the enable input to see if it works as desired. When enable is 1 we can see that the register program works as expected with all the outputs and inputs. When enable is 0, we can see that all outputs are labeled x, which means "don't care", this is because the program is disabled.

labm2.v
Here we test the 32bit register module by supplying random inputs of d at every 2 units of time. We negate the clk for oscillation at every 5 units of time. Whenever the clk hits the positive edge, the expectation value e gets assigned the latest d value. e is used by the oracle in the program for checking whether z has passed or failed. The variable "passed" is assigned 0 if failed or 1 if passed.

labm4.v
This programs test the write and read functionalities of the mem module. In order to read, first memRead must be assigned 1, then the 32 bit address must be provided for reading, after a delay the content of the address would be available in the memOut output. In order to write, the address must be specified, memIn would contain the content to be stored at the address and memWrite must be assigned 1. On the clk's positive edge, the value is stored. This program stores some values then reads them then displays them.

labm5.v
In the mem module there is a section in the code called "$readmemh("ram.dat", arr);". "arr" is array used to store memory. This code will parse the file "ram.dat" located in the working directory and instantiate all the data based on the address into the memory. The format for parsing is @a c, where a is the address and c is content. We took the machine code instructions of a risc-v.

labm6.v
Here we modified our previous program to output sections of the instruction machine instruction code that make up the entire code. For example, I type instructions will be split into 5 parts that is imm value, rs1, funct3, rd, and Opcode.

labm7.v
This program implements the yIF module created for instruction fetch done by the cpu. The yIF module contains 2 inputs PCin and clk and two outputs PCp4, and ins. PCin contains the address of the instruction in interest and gets stored inside an enabled PC register. When the clk rises from 0 to 1 the address goes into the ALU for incrementing the PC counter to PC+4 and goes into the memory for making the machine code instruction that was stored at the address available for reading through "ins". The program fetches all the instructions in ram.dat and displays it. This module is useful because it connects everything into the cpu, stores your address (PCin) in the PC register and not only will it fetch the instruction but will give you the address of the next instruction that is PC+4.

labm8.v
This program implements 3 modules, the 1st module is Instruction Fetch (IF) mentioned above, the 2nd module is Instruction Decode (ID). Instruction decode will take 4 inputs those are: ins, wd, RegWrite, and clk. And will give 4 outputs: rd1, rd2, imm, jTarget. IF will fetch the instruction "ins", then that instruction will be decoded. The outputs that we care about is rd1 32bits, rd2 32bits and imm 32 bits. We have now received the content inside register rd1 and rd2 that were in the instruction "ins", as well as the imm value. This where the 3rd module comes in, the execution module. We supply the execution module with rd1, rd2, imm, op (for alu) and ALUSrc. The op code supplied by the program will be used inside the ALU for calculation and is dependent on the instruction "ins". The ALUSrc will be used in a multiplexer for choosing between imm and rd2 to be used inside the alu for calculation. The ALUSrc will be supplied by the program and will be dependent on the type of instruction "ins". After the calculation is done by the ALU the module outputs zero if and only if z is 0 and outputs z which the product of the calculation. Finally, we take this product and assign it to wd. wd along with RegWrite and ins will be used inside the 2nd module for writing back into the destination register rd mentioned in the "ins" input on the positive edge of the clk. RegWrite should equal 1 to enable the writing process. PCin would equal to the jTarget or PCp4 or branch depending on what the instruction was and the process repeats until we have traced the first 11 executions of our program. This program is incomplete as it does not support data memory.

conclustion: This lab explains the memory aspect of the CPU. It deals with how the CPU stores and manages bits, fetches, decodes and executes instructions, as well as prepare the next instruction for execution.

